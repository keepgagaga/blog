[{"categories":null,"content":"很早之前找到的一个方案，使用下来感觉没啥毛病，除了每个页面都要引入麻烦些，原方案还拓展了 int，但感觉 double 能兼容 int 的绝大部分场景，偷个懒就只用 double 了。\n使用的时候按照设计图当前的尺寸改一下 standardWidth ，比如这里的意思就是当前设计图的尺寸是按 750 宽度设计的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  class SizeFit { static late MediaQueryData _mediaQueryData; static late double screenWidth; static late double screenHeight; static late double rpx; static late double px; static void initialize(BuildContext context, {double standardWidth = 750}) { _mediaQueryData = MediaQuery.of(context); screenWidth = _mediaQueryData.size.width; screenHeight = _mediaQueryData.size.height; rpx = screenWidth / standardWidth; px = screenWidth / standardWidth * 2; } // 按照像素来设置  static double setPx(double size) { return SizeFit.rpx * size * 2; } // 按照rpx来设置  static double setRpx(double size) { return SizeFit.rpx * size; } } extension DoubleFit on double { double get px { return SizeFit.setPx(this); } double get rpx { return SizeFit.setRpx(this); } } // use  Widget build(BuildContext context) { SizeFit.initialize(context); return Container( width: 100.rpx, height: 100.rpx, color: Colors.red, ); }   ","description":"","tags":null,"title":"Flutter_responsive","uri":"/posts/flutter_responsive/"},{"categories":null,"content":"下拉刷新 最简单的方法，使用 RefreshIndicator 组件，在 onRefresh 里刷新数据即可\n上拉加载更多 通过获取 ScrollController 的 maxScrollExtent 来确定有没有到底，然后在此基础上做加载更多的操作\n","description":"","tags":null,"title":"Flutter_pulldown_refresh_and_reach__bottom","uri":"/posts/flutter_pulldown_refresh_and_reach__bottom/"},{"categories":null,"content":"遇到一个一环扣一环的坑，真的是绝了。\n在做支付，支付完成后回到订单页面查询是否支付成功，然后更新总金额，但是遇到个诡异的事，成功获取总额后 setState 页面并没有更新总额，还是支付前的金额。\n一步步排查，金额获取到了，是对的，也执行了 setState，也重新 build 了页面，还是不行。\n就在看 build 部分的时候，突然发现热更新后也重新 build 了一次，而 setState 也会触发 build，但由于页面导航我在后面切换成了命名路由，于是接收页面参数的代码就放在了 build 方法里，然后这就会导致使用新的数据重新 build 时，前脚刚把数据更新成新的金额，后脚就在 build 时传入了路由带来的初始数据，于是页面的金额就怎么都不会改变了。\n解决方法就是把获取命名路由参数的步骤提到 initState 方法里，但直接放进去肯定会报错，因为这时候页面还没有绘制好，所以要用 Future.delayed(Duration.zero, () {}) 来包住，这样就可以了。\n","description":"","tags":null,"title":"route and applifecycle","uri":"/posts/route_applifecycle/"},{"categories":null,"content":"博客最难的不是搭建，如今在博客模版+GitHub的帮助下，搭建一个博客从未如此简单。\n困难的是写。算上从18年开始第一次折腾博客，到现在也三四年了，但真正写出来的文章屈指可数。\n我有点强迫症，经常会在一些小事情上纠结，比如GitHub账号名我已经修改了不下四五次了，博客模版也折腾好几个，都不太满意，从最早的rails搭建的博客，到express搭建的博客，再到博客模版+GitHub Page，强迫症太难受了。\n好在如今终于明白，对于博客来说，最重要的是去记录，是留下自己过去的痕迹，让自己在三年五年之后还能回忆起当初是如何思考的，虽然有很大概率会觉得之前的想法很蠢，但却不失为一种独特的记忆，毕竟，如果今天能看到小学时候的日记，我想无论当初的记录多蠢，我们都会怀念吧。\n","description":"","tags":null,"title":"开始记录","uri":"/posts/first/"}]
